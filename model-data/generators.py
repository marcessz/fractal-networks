"""
Generators for some fractal networks

"""
# Marcell Nagy <marcessz@math.bme.hu>
import networkx as nx
import random
import numpy as np


def uv_flower(u, v, n):
    # Returns a (u,v)-flower
    
    graph = nx.cycle_graph(u + v)
    for i in range(n - 1):
        for e in list(graph.edges):
            graph.remove_edge(e[0], e[1])

            path_nodes = [e[0]]
            for x in range(u - 1):
                path_nodes.append(graph.number_of_nodes())
                graph.add_node(graph.number_of_nodes())
                graph.add_edge(path_nodes[-2], path_nodes[-1])
            graph.add_edge(path_nodes[-1], e[1])

            path_nodes = [e[0]]
            for x in range(v - 1):
                path_nodes.append(graph.number_of_nodes())
                graph.add_node(graph.number_of_nodes())
                graph.add_edge(path_nodes[-2], path_nodes[-1])
            graph.add_edge(path_nodes[-1], e[1])

    return graph


def fractal_model(generation, m, e, x=1):
    """
    Returns the fractal model introduced by
    Song, Havlin, Makse in Nature Physics 2, 275.
    generation = number of generations
    m = number of offspring per edge end-point
    x = number of connections between offsprings
    e = rewiring probability of hubs
    If e=0 => pure small-world.
    If e=1 => pure fractal.
    """

    graph = nx.Graph()
    graph.add_edge(0, 1)  # This is the seed for the network (generation 0)
    node_index = 2
    for n in range(1, generation+1):
        all_links = list(graph.edges())
        while all_links:
            link = all_links.pop()
            new_nodes_a = range(node_index, node_index + m)
            node_index += m
            new_nodes_b = range(node_index, node_index + m)
            node_index += m
            graph.add_edges_from([(link[0], node) for node in new_nodes_a])
            graph.add_edges_from([(link[1], node) for node in new_nodes_b])

            if random.random() < e:
                graph.remove_edge(link[0], link[1])
                #new_links_a = random.sample(new_nodes_a, x)
                #new_links_b = random.sample(new_nodes_b, x)
                #new_links = list(zip(new_links_a, new_links_b))
                #graph.add_edges_from(new_links)
                repulsive_links = list(zip(new_nodes_a, new_nodes_b))
                graph.add_edges_from([repulsive_links[i] for i in range(x)])

    return graph


def hub_attraction_dynamical_growth_model(generations, m, a, b, t_cutoff, x=1):
    """
    Returns a fractal graph generated by the model, introduced by Li Kuang et al. in:
    "A Fractal and Scale-free Model of Complex Networks with Hub Attraction Behaviors"

    This is a modification of the previous fractal model

    :param generations: number of iterations
    :param m: number of new offsprings per edge end-point
    :param a: rewiring probability of hubs
    :param b: rewiring probability of non-hubs
    :param t_cutoff: threshold separating hubs and non-hubs
    :param x: number of connections between offsprings
    :return: graph
    """

    graph = nx.Graph()
    graph.add_edge(0, 1)
    node_index = 2
    t=1

    while t <= generations:
        all_links = list(graph.edges())
        degrees = dict(graph.degree)
        k_max = max(degrees.values())
        offsprings = {}  # dict: keys are nodes, values are set of new offsprings

        for edge in all_links:
            new_nodes_a = range(node_index, node_index + m)
            node_index += m
            new_nodes_b = range(node_index, node_index + m)
            node_index += m

            if edge[0] in offsprings:
                offsprings[edge[0]] = offsprings[edge[0]].union(set(new_nodes_a))
            else:
                offsprings[edge[0]] = set(new_nodes_a)

            if edge[1] in offsprings:
                offsprings[edge[1]] = offsprings[edge[1]].union(set(new_nodes_b))
            else:
                offsprings[edge[1]] = set(new_nodes_b)

            graph.add_edges_from([(edge[0], node) for node in new_nodes_a])
            graph.add_edges_from([(edge[1], node) for node in new_nodes_b])

            # degrees dictionary contains the degrees from the previous generation
            if degrees[edge[0]] / k_max > t_cutoff and degrees[edge[1]] / k_max > t_cutoff:
                e_prob = a
            else:
                e_prob = b

            if random.random() < e_prob:
                graph.remove_edge(edge[0], edge[1])
                repulsive_links = list(zip(new_nodes_a, new_nodes_b))
                graph.add_edges_from([repulsive_links[i] for i in range(x)])
    
        within_box_edges = []
        for node, offspg in offsprings.items():
            rnd_node = random.choice(list(offspg))
            within_box_edges += [(rnd_node, n) for n in random.sample(offspg - {rnd_node}, degrees[node])]

        graph.add_edges_from(within_box_edges)
        t+=1
  
    return graph


def repulsion_based_fractal_model(generations, m, Y, x=1):
    """
    Returns a fractal graph generated by the model, introduced by Marcell Nagy in:
    "Data-Driven Analysis of Fractality and Other Characteristics of Complex Networks"

    :param generations: number of iterations
    :param m: number of new offsprings per edge end-point
    :param Y: rewiring probability
    :param x: number of connections between offsprings
    :return: graph
    """

    graph = nx.Graph()
    graph.add_edge(0, 1)
    node_index = 2
    t = 1
    while t <= generations:
        all_links = list(graph.edges())
        degrees = dict(graph.degree)
        k_max = max(degrees.values())
        offsprings = {}
        for edge in all_links:
            new_nodes_a = range(node_index, node_index + m)
            node_index += m
            new_nodes_b = range(node_index, node_index + m)
            node_index += m

            if edge[0] in offsprings:
                offsprings[edge[0]] = offsprings[edge[0]].union(set(new_nodes_a))
            else:
                offsprings[edge[0]] = set(new_nodes_a)

            if edge[1] in offsprings:
                offsprings[edge[1]] = offsprings[edge[1]].union(set(new_nodes_b))
            else:
                offsprings[edge[1]] = set(new_nodes_b)

            graph.add_edges_from([(edge[0], node) for node in new_nodes_a])
            graph.add_edges_from([(edge[1], node) for node in new_nodes_b])

            e_prob = 1-abs(Y-(degrees[edge[0]]+degrees[edge[1]])/(2*k_max))

            if random.random() < e_prob:
                graph.remove_edge(edge[0], edge[1])
                repulsive_links = list(zip(new_nodes_a, new_nodes_b))
                graph.add_edges_from([repulsive_links[i] for i in range(x)])

        if m>1:
            within_box_edges = []
            for node, offspg in offsprings.items():
                rnd_node = random.choice(list(offspg))
                within_box_edges += [(rnd_node, n) for n in random.sample(offspg - {rnd_node}, degrees[node])]

            graph.add_edges_from(within_box_edges)

        t+=1
    return graph


def mixture_model_2d(n, m, p, a=10):
    """
    Returns a fractal graph generated by the model, introduced by Marcell Nagy in:
    "Data-Driven Analysis of Fractality and Other Characteristics of Complex Networks"
    
    :param n, m: parameters for a 2-dimensional grid graph (number of vertices: n x m)
    :param p: rewiring probability
    :return: graph
    
    During the rewiring procedure, the new endpoint is chosen according to the preferential attachment mechanism.
    """
    graph = nx.generators.lattice.grid_2d_graph(n,m)
    all_links = list(graph.edges())
    number_of_nodes = graph.number_of_nodes()

    while all_links:
        link=all_links.pop()
        if random.random() < p:
            degrees = dict(graph.degree)
            max_deg = max(degrees.values())
            degrees_copy = degrees.copy()

            for node in graph.neighbors(link[0]):
                degrees_copy.pop(node, None)

            del degrees_copy[link[0]]

            list_of_degrees=list(degrees_copy.values())
            if len(list_of_degrees)>0: 
                ### Ha nem maradna lehetséges új végpont akkor nem lép ide be --> nem történik semmi(megmarad az eredeti él)
                list_of_nodes=list(degrees_copy.keys())

                list_of_probs=[1/(1+np.exp(-a*(x / max_deg -0.5))) for x in list_of_degrees]

                graph.remove_edge(link[0], link[1])
                new_endpoint=random.choices(list_of_nodes, weights = list_of_probs, k=1)
                graph.add_edge(link[0],new_endpoint[0])

                if not nx.is_connected(graph):
                    graph.remove_edge(link[0], new_endpoint[0])
                
                    for node in graph.neighbors(link[1]):
                        degrees.pop(node, None)

                    del degrees[link[0]]
                    del degrees[link[1]]

                    list_of_degrees=list(degrees.values())
                    if len(list_of_degrees)>0:
                        list_of_nodes=list(degrees.keys())
                        list_of_probs=[1/(1+np.exp(-a*(x / max_deg -0.5))) for x in list_of_degrees]

                        new_endpoint=random.choices(list_of_nodes, weights = list_of_probs, k=1)
                    else:
                        new_endpont=[link[0]]
                        
                    graph.add_edge(link[1],new_endpoint[0])
 
    return graph